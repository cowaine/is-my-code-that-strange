# 이름 설계 : 구조를 파악할 수 있는 이름

## 악마를 불러들이는 이름
- 이름 설계가 부적절해 악마를 불러들이는 경우
- 이름을 너무 광범위하게 지으면, 여러 유스케이스와 관계를 맺는다(ex. 상품)
- 그러면 점점 거대하고 복잡해진 강한 결합 구조가 되어 버린다.

### 관심사 분리
- **관심사 분리** : 강한 결합을 해소하고, 결합이 느슨하고 응집도가 높은 구조로 만들기 위한 분리
- 관심사에 따라 각 클래스로 분리해야 한다.

### 관심사에 맞는 이름 붙이기
- 분할한 후 분할한 클래스 각각에 관심사에 맞는 로직을 캡슐화한다.
- 그러면 결합도가 낮아지고 응집도가 높아진다.
- 사양변경을 하게 되었을 때, 관련된 클래스만 확인하면 된다.

### 포괄적이고 의미가 불분명한 이름
- 개발 초기에 포괄적인 이름을 붙이는 경우가 많은데, 이런 경우 내부에 온갖 로직을 구현하게 된다.

## 이름 설계하기 - 목적 중심 이름 설계
- 관심사 분리를 생각하고, 비즈니스 목적에 맞게 '이름을 붙이는 것'은 결합이 느슨하고 응집도가 높은 구조를 만드는 데 굉장히 중요한 역할을 한다.
- 소프트웨어로 달성하고 싶은 목적과 의도를 이름만으로도 알 수 있게 해야한다.

### 최대한 구체적이고, 의미 범위가 좁고, 특화된 이름 선택하기
- 특정한 목적을 달성하는 데 특화된 의미 범위가 좁은 이름을 클래스에 붙인다.
- 다음과 같은 효과가 있다.
  - 이름과 관계없는 로직을 배제하기 쉬워짐
  - 클래스가 작아짐
  - 관계된 클래스 개수가 적으므로, 결합도가 낮아짐
  - 관계된 클래스 개수가 적으므로, 사양 변경 시 생각해야 하는 영향 범위가 좁음
  - 목적에 특화된 이름을 갖고 있으므로, 어떤 부분을 변경해야 할 때 쉽게 찾을 수 있음
  - 개발 생산성이 향상됨

### 존재가 아니라 목적을 기반으로 하는 이름 생각하기
- 존재를 나타내는 이름은 의미가 여러 곳에서 사용되기 쉬우며, 목적이 불분명해지기 쉽다.
- '주소' 보다는 '발송지'와 '배송지'처럼 목적 특화된 이름이 좋다.

### 어떤 관심사가 있는지 분석하기
- 소프트웨어가 추구하는 목적과 내용을 분석해야 한다.

### 소리 내어 이야기해 보기
- 고무 오리 디버깅 : 어떤 문제가 발생했을 때, 문제를 누군가에게 설명하다 보면 스스로 원인을 깨닫고 해결할 수 있다.
- 팀에서 유비쿼터스 언어를 사용할 때는 계속해서 대화하고, 계속해서 이름을 다듬어 나가는 것이 중요하다.

### 이용 약관 읽어 보기
- 이용 약관에는 서비스와 관련된 규칙이 굉장히 엄격한 표현으로 작성되어있다.

### 다른 이름으로 대체할 수 없는지 검토하기
- 일단 다른 이름으로 바꿔 보고, 의미를 더 좁게 만들 수는 없는지, 이상한 점은 없는지 검토하는 것이 좋다.

### 결합이 느슨하고 응집도가 높은 구조인지 검토하기
- 다른 클래스 몇 개와 연관되어 있는지 개수를 보고, 여러 개와 관련되어 있다면 좋지 않은 징조다.

## 이름 설계 시 주의 사항

### 이름에 관심 갖기
- 이름과 로직이 대응된다는 전제, 이름이 프로그램 구조를 크게 좌우한다는 사실을 팀원들과 이야기해야한다.

### 사양 변경 시 '의미 범위 변경' 경계하기
- 이름 설계는 중간중간 다시 검토해야 한다.
- 여러 의미가 섞이면, 이름이 의미하는 바를 다시 검토해봐야한다.

### 대화에는 등장하지만 코드에 등장하지 않는 이름 주의하기
- 대화에 자주 등장하는 중요한 개념이 소스 코드에서는 이름조차 붙어 있지 않고, 잡다한 로직에 묻혀있는 경우가 꽤 많다.

### 수식어를 붙여서 구별해야 하는 경우는 클래스로 만들어 보기
- `maxHitPoint`가 최대 히트 포인트를 나타낸다는 것은 알 수 있지만, '캐릭터의 원래 최대 히트포인트'인지, '장비 착용으로 높아진 최대 히트포인트'인지는 알 수 없다.
- 수식어를 붙이면서까지 차이를 나타내고 싶은 대상은 각각 클래스로 설계하는 것이 좋다.

## 의미를 알 수 없는 이름

### 기술 중심 명명
- 기술 중심 명명은 이름의 의도를 알기 어렵다.
- ex. `memory`, `cache`, `thread`, `method`...

### 로직 구조를 나타내는 이름
- 로직구조를 그대로 드러내면 무엇을 하려는지 알기 어렵다.
- ex. `isMemberHpMoreThanZeroAndIsMemberCanActAndIsMemberMpMoreThanMagicCostMp`

### 놀람 최소화 원칙
- 사용자가 예상하지 못한 놀라움을 최소화하도록 설계해야 한다.
- 이름으로 예상할 수 있는 만큼 로직이 존재해야 한다.
- 사양을 변경하면서 점차 괴리가 발생할 수 있다.

## 구조에 악영향을 미치는 이름

### 데이터 클래스처럼 보이는 이름
- `*Info`, `~Data` 같은 이름의 클래스는 읽는 사람에게 데이터 클래스처럼 느끼게 할 수 있다.
- 데이터 전송 용도로 사용되는 `DTO`는 예외이다.

### 클래스를 거대하게 만드는 이름
- 대표적으로 `*Manager` 명칭이 존재한다.
- 이름이 모호하므로 너무 많은 책무를 떠안아서 단일 책임 원칙을 위반하게 된다.
- 결국에 "갓 클래스"가 되고 만다.

### 상황에 따라 의미가 달라질 수 있는 이름
- `Account`는 상황에 따라 "계좌"와 "로그인 권한"이 될 수 있다.
- 컨테스트의 차이를 인지하고 있어야 한다.
- 다른 컨텍스트는 다른 패키지로 선언하면, 결합이 느슨해지고 서로 영향을 미치지 않는다.

### 일련번호 명명
- 변경하려고 해도 구조를 개선하기가 어려워 진다.
- ex. `Class001`, `method001`...

## 이름을 봤을 때, 위치가 부자연스러운 클래스
- 있어야 할 곳에 있지 않은 부자연스러움은 이름을 통해 판단할 수 있다.

### 동사 + 목적어 형태의 메서드 이름 주의하기
- "동사 + 목적어"로 이루어진 이름은 관계없는 책무를 가진 메서드일 가능성이 있다.

### 가능하면 메서드의 이름은 동사하나로 구성되게 하기
- 관심사가 다른 메서드가 섞이지 못하게 막으려면 되도록 메서드의 이름이 동사 하나로 구성되도록 설계하는 것이 좋다.

### 부적절한 위치에 있는 boolean 메서드
- `Common is member in confuse` 처럼 클래스와 대입하여 위화감이 없는지 확인한다.

## 이름 축약

### 의도를 알 수 없는 축약
- 이름이 축약되면 의도를 이해하기 어렵다.

### 기본적으로 이름은 축약하지 말기
- 조금 귀찮더라도 이름을 축약하지 말고 모두 쓰는 것이 좋다.

### 이름을 축약할 수 있는 경우
- `for`반복문의 카운터 변수는 스콥이 적으므로 괜찮다.
