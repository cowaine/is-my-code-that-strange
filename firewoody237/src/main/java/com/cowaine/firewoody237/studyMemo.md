# Good & Bad
- `Bad`
  1. 의미를 알 수 없는 이름(`/bad_code/Naming.java`)
    - **기술 중심 명명** : 비즈니스를 나타내기 어렵다.
    - **일련번호 명명** : 코드에서 의도를 알기 어렵다. 읽는데 오래 걸린다.
  2. 분기 중첩(`/bad_code/Condition.java`)
    - 블록의 scope 확인이 힘들어진다.
    - 읽고 이해하기 어렵다.
  3. 데이터 클래스(`/bad_code/Money.java`)
    - 로직이 클래스 밖에서 이루어진다면, 유지보수하기 어렵다.
      - 코드 중복 : 새로운 개발 시 중복 코드 생성 가능성
      - 수정 누락 : 모든 코드를 고쳐야 함으로, 누락 가능성
      - 가독성 저하 : 코드를 찾는 것 만으로 노력이 필요
      - 초기화 누락 : 초기화가 되지 않은 쓰레기 객체로 인해 NPE 발생 가능성
      - 잘못된 값 할당 : 데이터만 존재하면, 검증이 어렵고 잘못된 값이 대입될 가능성
    - 데이터 클래스는 다른 클래스가 여러 준비를 해주어야 하기 때문에, **미성숙한 클래스**다.

- `Good`
  1. 좋은 이름 & 그룹화(`/good_code/Naming.java`)
     - 의도를 알기 쉬운 이름을 붙인다.
     - 목적별로 변수를 따로 만들어 사용한다. (== 재할당을 하지 않는다)
     - 단순 나열이 아닌, 의미 있는 것을 모아 메서드를 만든다.
     - 관련된 데이터와 로직을 클래스로 모아놓는다. 
  2. 클래스 설계(`/good_code/Money.java`)
     - 정의
        - 클래스 하나로도 잘 동작할 수 있게 설계해야 한다.
        - 복잡한 초기 설정을 하지 않아도 곧바로 사용할 수 있게 해야 한다.
        - 클래스를 마음대로 조작해서 버그가 발생하는 일이 없게 해야한다.
        - 최소한의 조작 방법만 외부에 제공해야한다.(캡슐화)
        - 자기 방어 임무르 수행해야 한다.
     - 구성 요소
       - 인스턴스 변수
       - (인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는) 메서드
     - 좋은 디자인 패턴
       - 완전 생성자(`complete construct`)
         - 잘못된 상태로부터 클래스를 보호
         - 생성자에서 모든 인스턴스 변수를 초기화하고, 가드로 잘못된 값이 들어오는 것을 막는다.
       - 값 객체(`value object`)
         - 값을 클래스로 나타내는 디자인 패턴
         - 값과 로직을 응집도가 높은 구조로 만들 수 있다.

# Anti Pattern
- 쓰레기 객체(`TrashObject.java`)
  - 초기화 하지 않은 상태가 발생할 수 있는 클래스
