# 설계의 건전성을 해치는 여러 악마

## 데드 코드
```java
if (level > 99) {
    level = 99;
}

if (level == 1) { ... }
else if (level == 100) { ... }
```

- `Dead Code` : 절대로 실행되지 않는 조건 내부에 있는 코드 (도달 불가능한 코드)
- 코드의 가독성을 저하
  - 읽는 사람에게 의도에 대한 혼란을 야기
- 언젠가 버그가 될 가능성이 존재
  - 지금까지 실행되지 않던 `Dead Code`가 사양 변경에 의해 도달 가능한 코드로 변경 가능
- 발견하는 즉시 제거 필요
  - `Github`를 통해 이력 관리

## YAGNI(You ain't gonna need it) 원칙
> "지금 필요 없는 기능은 만들지 말라"
- 미래를 예측하고 개발하는 경우, 그 로직은 실제로 거의 사용되지도 않고 버그의 원인이 되기도 함
- 소프트웨어의 요구사항은 매일 변하기 때문에 미리 예측하고 구현해도 대부분 맞지 않음
- 지금 필요한 기능을 최대한 간단한 형태로 만드는 것이 가독성과 유지보수에 좋음

## 매직 넘버
```java
boolean isOk() {
    return 60 <= value;
}
```

- 설명이 없는 숫자
- 로직 내부에 직접 작성되어 있어서 의미를 알기 어려움
- 구현자 본인만 의도를 이해하고, 여러 중복코드를 생성
- 실수로 수정할 경우 버그의 위험성 존재

- 상수를 활용
```java
private static final int MINIMUM_COUNT = 60;

boolean isOk() {
    return MINIMUM_COUNT <= value;
}
```

## 문자열 자료형에 대한 집착
```java
String title = "타이틀,255,250,240,64";
```

- `List`를 사용해도 충분한 구조에, 굳이 `String`을 넣어 `split`등을 쓰는 것
- `split` 등 보조 메서드로 인해 가독성이 크게 저하
- 의미가 다른 값은 각각 다른 변수에 저장하는 것이 좋음

## 전역 변수
- 모든 곳에서 접근할 수 있는 변수(`public static`)
- 전역 변수의 변경에 대한 리스크가 존재
- 동기화가 필요한 경우에 `Lock`에의한 문제 발생 가능성 존재

- 영향 범위가 가능한 한 좁게 설계해야 함
- 관계없는 로직에서는 접근할 수 없게 설계가 필요

## `null` 문제
- `null`이 들어갈 수 있다고 전제하고 로직을 만들면 모든 곳에서 `null`체크를 해야 함

- `null`을 리턴하지 않는 설계
- `null`을 전달하지 않는 설계

```java
void takeOffAllEquipments() {
    head = Equipment.EMPTY;
    body = Equipment.EMPTY;
    arm = Equipment.EMPTY;
}
```

- 언어에서 지원하는 "null 안전 자료형"을 사용

## 예외를 `catch`하고서 무시하는 코드
```java
try {
    reservations.add(product);
} catch (Exception e) { }
```
- 원인 분석을 어렵게 만듦
  - 오류가 나더라도 오류를 탐지할 방법이 없음
  - 외부에서는 아무런 문제가 없는 것처럼 보이게 만듦

- 문제가 발생했다면 소리치기
  - 예외를 확인했다면 곧바로 통지, 기록
  - 상황에 따라서는 복구
```java
try {
    reservations.add(product);
} catch (Exception e) { 
    reportError(e);
    requestNotifyError("예약할 수 없는 상품");
}
```

## 설계 질서를 파괴하는 메타 프로그래밍
```java
Level level = Level.initialize();

Field field = Level.class.getDeclaredField("value");
field.setAccessible(true);
field.setInt(level, 999);
```
- **메타 프로그래밍** : 프로그램 실행 중에 해당 프로그램 구조 자체를 제어하는 프로그래밍 (리플렉션 등)
- 용도와 의도를 제대로 이해하지 못하고 사용하면, 전체적인 설계를 무너뜨릴 수 있음
- 리플렉션을 남용하면 '클래스를 보호하려는 노력', '좁은 영향범위 설계' 등이 아무런 의미가 없어짐
- IDE의 정적 분석을 사용하기 어렵기 때문에, 어떤 클래스가 어디에서 참조되고 있는지 정확한 분석이 어려움

- 단점을 이해하고 사용 필요
- 시스템 분석 용도로 한정하거나, 아주 작은 범위에서만 활용하는 등 리스크 최소화

## 기술 중심 패키징
- **기술 중심 패키징** : 구조에 따라 폴더와 패키지를 나누는 것
- 비즈니스 클래스는 관련된 비즈니스 개념을 기준으로 폴더를 구분하는 것이 좋음
  - 관계없는 유스케이스에서 다른 도메인을 참조할 위험이 적어짐

## 샘플 코드 복사해서 붙여넣기
- 샘플코드는 그대로 복붙하지 말아야 함
- 샘플코드는 어디까지나 참고만 하고, 클래스 구조를 잘 설계해서 사용 필요

## 은 탄환
> 은 탄환은 없다.
- **은 탄환** : 인간과 악마를 죽일 수 있는 총알, 어떤 문제를 해결하는 비장의 무기, 묘책
- 새로운 기술은 개발 현자으이 모든 문제를 해결해 줄 것처럼 매력적으로 보이기도 함
  - 하지만 현실에서 발생하는 여러 문제는 특정 기술 하나로 해결할 수 있을 정도로 단순하지 않음
- 중요한 것은 어떤 문제가 있을 때, 어떤 방법이 해당 문제에 효과적인지, 비용이 더 들지는 않는지 평가하고 판단하는 자세
- 문제와 목적을 머릿속에 새겨 두고, 적절한 기술을 선택할 수 있는 노력 필요
