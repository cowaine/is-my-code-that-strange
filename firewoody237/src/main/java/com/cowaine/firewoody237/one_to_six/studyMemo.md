# Good & Bad
- `Bad`
  1. 의미를 알 수 없는 이름(`/bad_code/Naming.java`)
    - **기술 중심 명명** : 비즈니스를 나타내기 어렵다.
    - **일련번호 명명** : 코드에서 의도를 알기 어렵다. 읽는데 오래 걸린다.
  2. 분기 중첩(`/bad_code/Condition.java`)
    - 블록의 scope 확인이 힘들어진다.
    - 읽고 이해하기 어렵다.
  3. 데이터 클래스(`/bad_code/Money.java`)
    - 로직이 클래스 밖에서 이루어진다면, 유지보수하기 어렵다.
      - 코드 중복 : 새로운 개발 시 중복 코드 생성 가능성
      - 수정 누락 : 모든 코드를 고쳐야 함으로, 누락 가능성
      - 가독성 저하 : 코드를 찾는 것 만으로 노력이 필요
      - 초기화 누락 : 초기화가 되지 않은 쓰레기 객체로 인해 NPE 발생 가능성
      - 잘못된 값 할당 : 데이터만 존재하면, 검증이 어렵고 잘못된 값이 대입될 가능성
    - 데이터 클래스는 다른 클래스가 여러 준비를 해주어야 하기 때문에, **미성숙한 클래스**다.
  4. 재할당(`/bad_code/ReAssign.java`)
    - 변수의 의미를 바꿔 추측하기 어렵게 만든다.
    - 재할당으로 가변 인스턴스가 된다면, 다른 곳에서 수정하는 등 사이드 이펙트가 발생한다.
    - 재할당으로 함수가 내부 속성을 변경한다면, 다른 스레드에 의해 값이 변경되는 상황이 발생할 수 있다.
    - 부수효과가 발생하여 상태변경(함수 밖에 있는 상태를 변경)을 일으킬 수 있다.
  5. 낮은 응집도(`/bad_code/Coupling.java`)
    - `static` 메서드 오용
      - 데이터와 로직이 분리되기 쉽다.
      - 인스턴스변수를 사용할 수 없으므로 `static`으로 만든 시점에서 이미 데이터와 로직 사이에 괴리가 생긴다.
      - 인스턴스 메서드인 척하는 `static` 메서드를 주의해야 한다.
      - `static` 메서드는 객체 지향 언어를 사용할 때, 절차 지향 언어의 접근 방법을 사용하려 하기 때문이다.
      - 응집도의 영향을 받지 않는 경우에만 `static` 메서드를 사용해야 한다. (or 팩토리 메서드)
    - 초기화 로직 분산(`/bad_code/GiftPoint.java`)
      - 초기화 로직 분산은 의도치 않은 용도로 사용되거나, 로직이 분산되어 유지 보수가 힘들다.
    - 범용 클래스(`/bad_code/Common.java`)
      - 매우 높은 확률로 응집도가 낮은 구조가 만들어진다.
      - 전역변수가 나타나게 되는 등 여러 악영향을 미친다.
      - 관련없는 너무 많은 로직이 한 클래스에 모이게 된다.
    - 결과를 리턴하는 데 매개변수 사용하기(`/bad_code/ActorManager.java`)
      - 매개변수를 잘못 다루면 응집도가 낮아진다.
    - 매개변수가 너무 많은 경우(`/bad_code/ToManyParameters.java`)
      - 기본 자료형에 집착을 하면 코드 중복이 쉽게 발생할 수 있다.(ex .유효성 검사)
      - 기본 자료형에 집착을 하면 데이터를 사용한 계산과 제어 로직이 모두 분산된다.(응집도가 낮아짐)
    - 메서드 체인(`/bad_code/NoDemeter.java`)
  6. 나쁜 조건 분기
     - 중첩된 조건 분기(`/bad_code/BadIf.java`)
     - 반복되는 스위치문(`/bad_code/MagicManager.java`)
     - 플래그 매개변수(`/bad_code/Flag.java`)

- `Good`
  1. 좋은 이름 & 그룹화(`/good_code/Naming.java`)
     - 의도를 알기 쉬운 이름을 붙인다.
     - 목적별로 변수를 따로 만들어 사용한다. (== 재할당을 하지 않는다)
     - 단순 나열이 아닌, 의미 있는 것을 모아 메서드를 만든다.
     - 관련된 데이터와 로직을 클래스로 모아놓는다. 
  2. 클래스 설계(`/good_code/Money.java`)
     - 정의
        - 클래스 하나로도 잘 동작할 수 있게 설계해야 한다.
        - 복잡한 초기 설정을 하지 않아도 곧바로 사용할 수 있게 해야 한다.
        - 클래스를 마음대로 조작해서 버그가 발생하는 일이 없게 해야한다.
        - 최소한의 조작 방법만 외부에 제공해야한다.(캡슐화)
        - 자기 방어 임무르 수행해야 한다.
     - 구성 요소
       - 인스턴스 변수
       - (인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는) 메서드
     - 좋은 디자인 패턴
       - 완전 생성자(`complete construct`)
         - 잘못된 상태로부터 클래스를 보호
         - 생성자에서 모든 인스턴스 변수를 초기화하고, 가드로 잘못된 값이 들어오는 것을 막는다.
       - 값 객체(`value object`)
         - 값을 클래스로 나타내는 디자인 패턴
         - 값과 로직을 응집도가 높은 구조로 만들 수 있다.
  3. 불변(`/good_code/Immutable.java`)
     - 불변(`final`)으로 재할당을 막는다.
     - 장점
       - 변수의 의미가 변하지 않으므로, 혼란을 줄여준다.
       - 동작이 안정적이게 되므로, 결과를 예측하기 쉽다.
       - 코드의 영향 범위가 한정적이므로, 유지 보수가 편리해진다.
     - 함수의 부수효과를 막으려면 아래 조건을 만족하도록 설계하는 것이 좋다.
       - 데이터는 매개변수로 받는다.
       - 상태를 변경하지 않는다.
       - 값은 함수의 리턴 값으로 돌려준다.
     - 객체지향 프로그래밍 언어는 함수의 부수 효과로 인한 범위를 **클래스 내부**까지 허용하는 것이 일반적이다.
     - 가변으로 설계해야 하는 경우
       - 성능이 중요한 경우(리소스 제약이 큰 임베디드 소프트웨어 등)
       - 스코프가 국소적인 경우
  4. 응집도
     - 클래스 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지 나타내는 지표
     - 초기화 로직을 응집시키기 위해, 팩토리 메서드를 활용할 수 있다.(`/good_code/GiftPoint.java`)
     - 범용 클래스보다는, 재사용성을 높어야 한다. 
     - 횡단 관심사(로그, 디버깅, 예외처리...)는 범용 코드로 만들어도 괜찮다.
     - 결과를 리턴하는 데 매개변수 사용하지 않기(`/good_code/Location.java`)
     - 기본자료형에 대한 집착을 버리고, 의미있는 단위는 클래스로 만든다.(`/good_code/NotManyParameters.java`)
     - 디미터 법칙
       - 사용하는 객체 내부를 알아서는 안 된다.
       - Tell Don't Ask : 다른 객체의 내부 상태를 기반으로 판단하거나 제어하려고 하지말고, 메서드로 명령해서 객체가 알아서 판단고 제어하도록 설계하라.
       - 사용할 객체에게 "메시지"를 보낸다.
  5. 좋은 조건 분기
      - 조기 리턴(`/good_code/GoodIf.java`)
      - switch -> 전략패턴으로 대체(`/good_codee/MagicManager.java`)
      - 정책 패턴(`/bad_code/MembershipManager.java` -> `/good_code/GoldCustomerPolicy.java`)
      - 리스코프 치환원칙(`/bad_code/RegularRates.java` -> `/good_code/RegularRates.java`)
      - 조건 분기를 써야하는 상황에는 일단 인터페이스 설계를 떠올리자를 머리속에 새겨 두기만 해도 조건 분기 처리를 대하는 방식 자체가 달라진다.
      - 메서드 분리(`/good_code/SeparateMethod.java`)

# Anti Pattern
- 쓰레기 객체(`TrashObject.java`)
  - 초기화 하지 않은 상태가 발생할 수 있는 클래스
